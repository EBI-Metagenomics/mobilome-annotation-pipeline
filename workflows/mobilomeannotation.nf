include { validateParameters ; paramsHelp ; samplesheetToList } from 'plugin/nf-schema'

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    IMPORT MODULES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

// Inputs preparing modules
include { RENAME           } from '../modules/rename_contigs'

// Annotation modules
include { PRODIGAL         } from '../modules/prodigal'
include { ARAGORN          } from '../modules/aragorn'
include { TRNAS_INTEGRATOR } from '../modules/trnas_integrator'
include { PROKKA           } from '../modules/prokka'
include { AMRFINDER_PLUS   } from '../modules/amrfinder_plus'

// Mobile genetic elements prediction modules
include { INTEGRONFINDER   } from '../modules/integronfinder'
include { ISESCAN          } from '../modules/isescan'
include { GENOMAD          } from '../modules/genomad'
include { VIRIFY_QC        } from '../modules/virify_qc'

// Results integration and writing modules
include { AMRFINDER_REPORT } from '../modules/amrfinder_report'
include { FASTA_WRITER     } from '../modules/fasta_writer'
include { GFF_MAPPING      } from '../modules/gff_mapping'
include { GFF_VALIDATOR    } from '../modules/gff_validator'
include { INTEGRATOR       } from '../modules/integrator'

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    IMPORT SUBWORKFLOWS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/
include { COMPOSITIONAL_OUTLIER_DETECTION } from '../subworkflows/compositional_outlier_detection'
include { ICEFINDER2_LITE                 } from '../subworkflows/icefinder2-lite'

// TODO: add diamond based annotation subworkflow for genes and pathofact modules


/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    RUN MAIN WORKFLOW
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

workflow MAIN {

    validateParameters()

    def ch_inputs = Channel.fromList(samplesheetToList(params.input, "./assets/schema_input.json"))

    // PREPROCESSING
    RENAME( ch_inputs.map { meta, fasta, _user_proteins_gff, _virify_gff -> [meta, fasta] } )

    // Initialize channels
    def assembly_faa_gff_ch = Channel.empty()
    def assembly_gff_ch = Channel.empty()
    def amr_finder_ch = Channel.empty()
    def to_append_gff_ch = Channel.empty()


    /*
    ******************************************************************************************************
    * The GFF assembly can be either provided by the user or generated by PROKKA.
    * If provided by the user, the -run_prokka option is automatically disabled.
    * When PROKKA is used, AMRFinderPlus is also executed.
    * CDS and tRNA predictions are required for MGE quality control.
    * The GFF output from PROKKA is suitable for this purpose.
    * If the user provides their own GFF or PROKKA is disabled,
    * we generate CDS and tRNA annotations separately,
    * since user input may not be reliable for our QC steps.
    */

    // Handle prokka, prodigal and user_gff logic
    if ( params.run_prokka ) {
        PROKKA( RENAME.out.contigs_1kb )
        
        // Populate channels from PROKKA outputs
        assembly_faa_gff_ch = PROKKA.out.prokka_faa.join( PROKKA.out.prokka_gff )
        assembly_gff_ch = PROKKA.out.prokka_gff
        amr_finder_ch = PROKKA.out.prokka_fna
            .join( PROKKA.out.prokka_faa )
            .join( PROKKA.out.prokka_gff )

        // Create to_append_gff_ch from prokka output
        to_append_gff_ch = PROKKA.out.prokka_gff.map { meta, gff_file ->
            tuple(meta, gff_file, 'prokka')
        }
    } else {
        // Run PRODIGAL + ARAGORN pipeline
        PRODIGAL( RENAME.out.contigs_1kb )
        ARAGORN( RENAME.out.contigs_1kb )
        TRNAS_INTEGRATOR( ARAGORN.out.rnas_tbl.join( PRODIGAL.out.gff ).join( PRODIGAL.out.faa ) )
        
        // Populate channels from PRODIGAL/ARAGORN outputs
        assembly_faa_gff_ch = TRNAS_INTEGRATOR.out.merged_faa.join(TRNAS_INTEGRATOR.out.merged_gff)
        assembly_gff_ch = TRNAS_INTEGRATOR.out.merged_gff
        
        // AMR finder channel remains empty for prodigal path
        amr_finder_ch = Channel.empty()

        // Handle user-provided GFF files
        to_append_gff_ch = ch_inputs
            .map { meta, _fasta, user_gff, _virify_gff -> 
                if ( user_gff && user_gff != [] ) {
                    tuple(meta, user_gff, 'user')
                } else {
                    null  // Will be filtered out
                }
            }
            .filter { it != null }  // Remove null entries
    }


    // PREDICTION
    // Collecting ICEfinder2 databases and input files
    db_ice_hmm_models = Channel.fromPath("${params.ice_hmm_models}.*", checkIfExists: true)
                        .collect()
                        .map { ice_db_files ->
                            [[id: file(params.ice_hmm_models).name ], ice_db_files]
                        }
    db_prokka_uniprot = Channel.fromPath("${params.prokka_uniprot_db}.*", checkIfExists: true)
                        .collect()
                        .map { uniprot_db_files ->
                            [[id: file(params.prokka_uniprot_db).name], uniprot_db_files]
                        }

    def icf2_inputs = RENAME.out.contigs_5kb.join(
        assembly_faa_gff_ch.map{meta, faa, _gff -> tuple(meta, faa) }
        ).join(
        assembly_faa_gff_ch.map{meta, _faa, gff -> tuple(meta, gff) }
        )

    ICEFINDER2_LITE( 
        icf2_inputs,
        db_ice_hmm_models, 
        params.ice_macsy_models, 
        db_prokka_uniprot
    )

    // Runnging other prediction modules
    GENOMAD( RENAME.out.contigs_5kb )

    INTEGRONFINDER( RENAME.out.contigs_5kb )

    ISESCAN( RENAME.out.contigs_1kb )

    COMPOSITIONAL_OUTLIER_DETECTION( RENAME.out.contigs_100kb )


    // Parsing VIRify gff file when an input is provided
    def user_virify_gff_ch = ch_inputs.map { meta, _fasta, _user_gff, virify_gff -> {
           [meta, virify_gff]
        }
    }.filter { _meta, virify_gff -> virify_gff != [] }

    VIRIFY_QC( user_virify_gff_ch )


    /**********************************************************************************************
    * The INTEGRATOR step takes a bunch of outputs from the previous steps.
    * The following code is re-shaping the input to accommodate
    * optional inputs such as the user-provided GFF.
    * This is done this way because Nextflow doesn't handle optional inputs. One hack that the
    * community uses for inputs of type path is to provide an empty array ([]). So, we first
    * join with user-provided GFF with the remainder, try to get an empty element, and then we use map
    * to transform the null to [].
    ***********************************************************************************************/
    def integrator_ch = 
        assembly_gff_ch
    .join(
        RENAME.out.map_file
    ).join(
        ISESCAN.out.iss_tsv
    ).join(
        INTEGRONFINDER.out.contigs_summary
    ).join(
        INTEGRONFINDER.out.contigs_gbks
    ).join(
        ICEFINDER2_LITE.out.ices_tsv, remainder: true
    ).join(
        GENOMAD.out.genomad_vir
    ).join(
        GENOMAD.out.genomad_plas
    ).join(
        COMPOSITIONAL_OUTLIER_DETECTION.out.bed, remainder: true
    ).join(
        VIRIFY_QC.out.virify_hq, remainder: true
    )

    INTEGRATOR(
        integrator_ch.map {
            meta,
            assem_gff, 
            map_file, 
            iss_tsv, 
            contigs_summary, 
            gbks, 
            ices_tsv, 
            genomad_vir, 
            genomad_plas, 
            compos_bed, 
            virify_hq 
                -> {[
                meta, 
                assem_gff,
                map_file, 
                iss_tsv, 
                contigs_summary, 
                gbks, 
                ices_tsv ? ices_tsv : [], 
                genomad_vir, 
                genomad_plas, 
                compos_bed ? compos_bed : [], 
                virify_hq ? virify_hq : [] 
            ]}
        }
    )

    // POSTPROCESSING
    // Writing fasta file
    FASTA_WRITER(
        ch_inputs.map { meta, fasta, _user_proteins_gff, _virify_gff -> [meta, fasta] }
        .join(
            INTEGRATOR.out.mobilome_gff 
        )
    )

    // Validating the mobilome gff file
    if ( params.gff_validation ) {
        GFF_VALIDATOR( INTEGRATOR.out.mobilome_gff )
    }


    // Merging genes annotation on user gff or prokka, when available
    def valid_to_append_gff_ch = to_append_gff_ch
        .filter { meta, gff_file, label ->
            gff_file && gff_file != [] && label != null
        }

    GFF_MAPPING(
        INTEGRATOR.out.mobilome_gff.join( RENAME.out.map_file ).join( valid_to_append_gff_ch )
    )


    // Run AMR finder if we have valid inputs
    def valid_amr_ch = amr_finder_ch
        .filter { meta, fna, faa, gff ->
            fna && faa && gff && 
            fna != [] && faa != [] && gff != [] &&
            fna.size() > 0 && faa.size() > 0 && gff.size() > 0
        }

    AMRFINDER_PLUS( valid_amr_ch ) 
        
    AMRFINDER_REPORT(
        AMRFINDER_PLUS.out.amrfinder_tsv
        .join( INTEGRATOR.out.mobilome_gff )
        .join( RENAME.out.map_file )
        .join( to_append_gff_ch.map { meta, gff, label -> [meta, gff] } )
    )
  
}
