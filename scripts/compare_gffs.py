#!/usr/bin/env python
import argparse
import os

def parse_args():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description="Compare results in two GFF files")
    parser.add_argument('--gff_file1', type=str, required=True, help="GFF file generated with method 1 to compare")
    parser.add_argument('--gff_file2', type=str, required=True, help="GFF file generated with method 2 to compare")
    parser.add_argument('--feature', type=str, required=True, help="Feature to search in column 2")
    parser.add_argument('--annot_type', nargs="*", required=False, help="List of annotation types to keep in column 3, space separated. If None, all types will be used for comparison without grouping")
    parser.add_argument('--output', type=str, required=True, help="Sample name to be used in column 1 of results and as prefix for the output files")
    args = parser.parse_args()
    return args


def read_gff(file_name, feature, annot_type):
    annotations_dict = {}
    with open(file_name, 'r') as file_in:
        for line in file_in:
            line_l = line.rstrip().split("\t")
            # Annotation lines have exactly 9 columns
            if len(line_l) == 9:
                (
                    contig,
                    seq_source,
                    seq_type,
                    start,
                    end,
                    score,
                    strand,
                    phase,
                    attr,
                ) = line.rstrip().split("\t")

                if seq_source == feature and seq_type in annot_type:
                    info = ( int(start), int(end), seq_type )

                    if contig in annotations_dict:
                        annotations_dict[contig].append(info)
                    else:
                        annotations_dict[contig]= [info]

    return annotations_dict


def compare_gffs(gff1, gff2, annot_type, output):
    all_contigs = set()

    print("Counting features in gff files generated with method 1 and method 2...")
    types_counts_1, types_counts_2 = {}, {}
    for group in annot_type:
        types_counts_1[group] = 0
        types_counts_2[group] = 0

    for contig in gff1:
        all_contigs.add(contig)
        for start, end, pred_type in gff1[contig]:
            types_counts_1[pred_type] += 1

    for contig in gff2:
        all_contigs.add(contig)
        for start, end, pred_type in gff2[contig]:
            types_counts_2[pred_type] += 1


    # Writing the counts output
    with open(output + '_types_counts.tsv', 'w') as types_out:
        header = ['sample', 'method'] + annot_type
        types_out.write('\t'.join(header) + '\n')

        to_print = [output, 'm1']
        for group in annot_type:
            to_print.append(str(types_counts_1[group]))
        types_out.write('\t'.join(to_print) + '\n' )

        to_print = [output, 'm2']
        for group in annot_type:
            to_print.append(str(types_counts_2[group]))
        types_out.write('\t'.join(to_print) + '\n' )

    # Comparison at coordinates level
    print("Comparing annotations at coordinates level...")
    overlapped_1 = {}
    overlapped_2 = {}
    high_overlap, med_overlap, low_overlap = 0, 0, 0
    same_type, diff_type = 0, 0
    for contig in all_contigs:
        if contig in gff1 and contig in gff2:
            overlapped_1[contig] = []
            overlapped_2[contig] = []
            for pred_m1 in gff1[contig]:
                m1_s = pred_m1[0]
                m1_e = pred_m1[1]
                m1_t = pred_m1[2]
                m1_l = m1_e - m1_s
                m1_range = range(m1_s, m1_e + 1)
                for pred_m2 in gff2[contig]:
                    m2_s = pred_m2[0]
                    m2_e = pred_m2[1]
                    m2_t = pred_m2[2]
                    m2_l = m2_e - m2_s
                    m2_range = range(m2_s, m2_e + 1)
                    intersection = len(list(set(m1_range) & set(m2_range)))
                    if intersection > 0:
                        overlapped_1[contig].append(pred_m1)
                        overlapped_2[contig].append(pred_m2)
                        m1_cov = float(intersection) / float(m1_l)
                        m2_cov = float(intersection) / float(m2_l)
                        if m1_t == m2_t:
                            same_type += 1
                        else:
                            diff_type += 1
                        if m1_cov > 0.75 or m2_cov > 0.75:
                            high_overlap += 1
                        elif m1_cov >= 0.50 or m2_cov >= 0.50:
                            med_overlap += 1
                        elif m1_cov > 0.0 or m2_cov > 0.00:
                            low_overlap += 1


    # Finding unique predictions generated by each method
    print("Finding unique predictions generated by each method...")
    uniq_1, uniq_2 = 0, 0
    for contig in gff1:
        for prediction in gff1[contig]:
            if contig in overlapped_1:
                if prediction not in overlapped_1[contig]:
                    prediction_type = prediction[2]
                    uniq_1 += 1
                    print('Unique prediction by method 1: ',prediction)
            else:
                prediction_type = prediction[2]
                uniq_1 += 1
                print('Unique prediction by method 1: ',prediction)

    for contig in gff2:
        for prediction in gff2[contig]:
            if contig in overlapped_2:
                if prediction not in overlapped_2[contig]:
                    prediction_type = prediction[2]
                    uniq_2 += 1
                    print('Unique prediction by method 2: ',prediction)
            else:
                prediction_type = prediction[2]
                uniq_2 += 1
                print('Unique prediction by method 2: ',prediction)



    # Writing the overlapping output
    overlapping_tiers = [
        '100-75',
        '50-75',
        '0-50'
    ]
    with open(output + '_overlapping.tsv', 'w') as overlap_out:
        header = ['sample'] + overlapping_tiers + ['unique_m1', 'unique_m2', 'correct_name', 'wrong_name']
        overlap_out.write('\t'.join(header) + '\n')

        # Gathering the overlapping predictions
        to_print = [
            output, 
            str(high_overlap),
            str(med_overlap),
            str(low_overlap),
            str(uniq_1),
            str(uniq_2),
            str(same_type),
            str(diff_type),        
        ]
        overlap_out.write('\t'.join(to_print) + '\n')




def main():
    args = parse_args()

    # Parsing gff files
    print("Analysing sample "+args.output+"...")
    print("Parsing the gff files generated with method 1 and method 2...")
    annotations_dict_1 = read_gff(args.gff_file1, args.feature, args.annot_type)
    annotations_dict_2 = read_gff(args.gff_file2, args.feature, args.annot_type)

    # Generating stats
    compare_gffs(annotations_dict_1, annotations_dict_2, args.annot_type, args.output)

    print("Comparison done!")

if __name__ == "__main__":
    main()


