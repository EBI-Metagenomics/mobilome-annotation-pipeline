#!/usr/bin/env python
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=FutureWarning)

from Bio import SeqIO
import argparse
import sys
import os.path
import glob

##### This script integrates the outputs of MoMofy and VIRify to generate a single gff file
##### Alejandra Escobar, EMBL-EBI
##### March 14, 2023

parser = argparse.ArgumentParser(
        description='This script integrates the outputs of MoMofy and VIRify to generate a single gff file. It also use the PPR-meta output generated by VIRify to label plasmids and the MobileOG-DB annotation generated by MoMofy. Please provide the relevant input files')
parser.add_argument('--virify_gff', type=str, help='Virify output in gff format')
parser.add_argument('--checkv_summ', nargs='*', help='checkv original summary files')
parser.add_argument('--momofy_gff', type=str, help='MoMofy output in gff format')
parser.add_argument('--pprmeta', type=str, help='Find the file in VIRify output 01-viruses/pprmeta/pprmeta.csv')
parser.add_argument('--original_assem', type=str, help='Original assembly fasta file')
parser.add_argument('--renamed_virify', type=str, help='Renamed assembly fasta file')
args = parser.parse_args()


### Setting up variables
viri=args.virify_gff
checkv=args.checkv_summ
momo=args.momofy_gff
pprm=args.pprmeta
ori_fasta=args.original_assem
ren_fasta=args.renamed_virify

### Creating an ID conversion dict
originals=[]
if os.stat(ori_fasta).st_size > 0:
    for record in SeqIO.parse(ori_fasta, "fasta"):
        originals.append(str(record.id))

renamed=[]
if os.stat(ren_fasta).st_size > 0:
    for record in SeqIO.parse(ren_fasta, "fasta"):
        renamed.append(str(record.id))

contig_names=dict(zip(renamed, originals))


### Saving ppr-meta predictions
plasmids={}
if os.stat(pprm).st_size > 0:
    with open(pprm,'r') as input_csv:
        next(input_csv)
        for line in input_csv:
            Header,Length,phage_score,chromosome_score,plasmid_score,Possible_source=line.rstrip().split(',')
            if Possible_source=='plasmid':
                contig=contig_names[Header]
                plasmids[contig]=Length

### Saving checkV metadata
checkv_pass=[]
for summ_file in checkv:
    if os.path.exists(summ_file):
        with open(summ_file,'r') as input_table:
            next(input_table)
            for line in input_table:
                l_line=line.rstrip().split('\t')
                phage_id=l_line[0]
                viral_genes=int(l_line[5])
                checkv_quality=l_line[7]
                kmer_freq=float(l_line[12])
                if all([ viral_genes>0 , checkv_quality != 'Not-determined' ]):
                    if any([ checkv_quality=='Low-quality' , checkv_quality=='Medium' ]):
                        if kmer_freq <= 1.0:
                            checkv_pass.append(phage_id)
                    else:
                        checkv_pass.append(phage_id)


### Saving virify predictions
phages_metadata={}
contig_phages={}
protcoord_protid={}
viralprot_annot={}
if os.path.exists(viri):
    with open(viri,'r') as input_gff:
        for line in input_gff:
            if not line.startswith('#'):
                contig,source,seq_type,start,end,score,strand,phase,attributes=line.rstrip().split('\t')
                if seq_type == 'prophage':
                    seq_id=contig+'|'+seq_type+'-'+start+':'+end
                    if seq_id in checkv_pass:
                        phages_metadata[seq_id]=(contig,source,seq_type,start,end,score,strand,phase,attributes)
                        if contig not in contig_phages.keys():
                            contig_phages[contig]=[seq_id]
                        else:
                            contig_phages[contig].append(seq_id)
                elif seq_type == 'viral_sequence':
                    seq_id=contig
                    if seq_id in checkv_pass:
                        phages_metadata[seq_id]=(contig,source,seq_type,start,end,score,strand,phase,attributes)
                        contig_phages[contig]=[seq_id]
                elif seq_type=='CDS':
                    protein_id=attributes.split(';')[0].replace('ID=','')
                    seq_belong=protein_id.split('_')
                    seq_belong.pop(-1)
                    seq_belong='_'.join(seq_belong)
                    if seq_belong in phages_metadata.keys():
                        viralprot_annot[protein_id]=(contig,source,seq_type,start,end,score,strand,phase,attributes)
                        protcoord_protid[(contig,start,end)]=protein_id                        


### Parsing momofy output and adding virify and ppr-meta predictions
## Restoring protein ID on virify proteins
output_gff='mobilome_predictions.gff'
used_contigs=[]
momo_pred={}
momo_labels=[
    'integron',
    'conjugative_transposon'
]
pl_counter=0
with open(momo,'r') as input_table, open(output_gff, 'w') as to_gff:
    for line in input_table:
        l_line=line.rstrip().split('\t')
        if len(l_line)==9:
            seqid=l_line[0]

            # Printing plasmids and viral predictions
            if not seqid in used_contigs:
                used_contigs.append(seqid)
                if seqid in plasmids.keys():
                    pl_counter+=1
                    plas_id='plasmid_'+str(pl_counter)
                    source='PPR-meta'
                    seq_type='plasmid'
                    start='1'
                    end=plasmids[seqid]
                    score='.'
                    strand='.'
                    phase='.'
                    attributes='ID='+plas_id+';gbkey=mobile_element;mobile_element_type=plasmid'
                    gff_line=[seqid,source,seq_type,start,end,score,strand,phase,attributes]
                    gff_line='\t'.join(gff_line)
                    to_gff.write(gff_line+'\n')

                if seqid in contig_phages.keys():
                    for phage in contig_phages[seqid]:
                        gff_line='\t'.join(phages_metadata[phage])
                        to_gff.write(gff_line+'\n')

            # Printing the rest of the annotations
            source=l_line[1]
            seq_type=l_line[2]
            start=l_line[3]
            end=l_line[4]
            score=l_line[5]
            strand=l_line[6]
            phase=l_line[7]
            attrib=l_line[8]
            prot_id=attrib.split(';')[0].replace('ID=','')
            composite_key=(seqid,start,end)
            if composite_key in protcoord_protid.keys():
                viphog_annot=viralprot_annot[protcoord_protid[composite_key]][8].split(';')[2]
                viphog_taxonomy=viralprot_annot[protcoord_protid[composite_key]][8].split(';')[3]
                new_attrib=attrib+';'+viphog_annot+';'+viphog_taxonomy
                gff_line=[seqid,source,seq_type,start,end,score,strand,phase,new_attrib]
                gff_line='\t'.join(gff_line)
                to_gff.write(gff_line+'\n')
            else:
                to_gff.write(line)

            # Catching momofy predictions
            if seq_type in momo_labels:
                metadata=(seqid,source,seq_type,start,end,score,strand,phase,attrib)
                mge_id=attrib.split(';')[0].replace('ID=','')
                momo_pred[mge_id]=metadata

        else:
            to_gff.write(line)


## Finding overlapping predictions
with open('integron_phage_overlapps.txt', 'w') as to_over:
    to_over.write('#contig\tintegron_ID\tphage_ID\tintegron_cov\tphage_cov\tintegron_len\tphage_len\n')
    for integron in momo_pred.keys():
        m_contig=momo_pred[integron][0]
        m_seqtype=momo_pred[integron][2]
        m_start=int(momo_pred[integron][3])
        m_end=int(momo_pred[integron][4])
        m_atrib=momo_pred[integron][8]
        m_range=range(m_start,m_end+1)
        m_len=m_end-m_start

        for phage in phages_metadata.keys():
            p_contig=phages_metadata[phage][0]
            p_seqtype=phages_metadata[phage][2]
            p_start=int(phages_metadata[phage][3])
            p_end=int(phages_metadata[phage][4])
            p_atrib=phages_metadata[phage][8]
            p_range=range(p_start,p_end+1)
            p_len=p_end-p_start

            if m_contig==p_contig:
                intersection=len(list(set(m_range) & set(p_range)))
                if intersection>0:
                    m_cov=float(intersection)/float(m_len)
                    p_cov=float(intersection)/float(p_len)
                    if any([ m_cov>0.9 , p_cov>0.9 ]):
                        to_over.write(m_contig+'\t'+integron+'\t'+phage+'\t'+str(m_cov)+'\t'+str(p_cov)+'\t'+str(m_len)+'\t'+str(p_len)+'\n')

